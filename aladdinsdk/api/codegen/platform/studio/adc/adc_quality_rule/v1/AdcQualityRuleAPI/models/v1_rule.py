# coding: utf-8

"""
    Adc Quality Rule

    Manages Data Qualiy Rules in Aladdin Data Cloud (ADC). Used by Dataset Owners and ADCQualityAnalysisServer.  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
from aladdinsdk.api.codegen.platform.studio.adc.adc_quality_rule.v1.AdcQualityRuleAPI.models.v1_applied_on_type import V1AppliedOnType
from aladdinsdk.api.codegen.platform.studio.adc.adc_quality_rule.v1.AdcQualityRuleAPI.models.v1_comparison_data_type import V1ComparisonDataType
from aladdinsdk.api.codegen.platform.studio.adc.adc_quality_rule.v1.AdcQualityRuleAPI.models.v1_comparison_type import V1ComparisonType
from aladdinsdk.api.codegen.platform.studio.adc.adc_quality_rule.v1.AdcQualityRuleAPI.models.v1_operator_type import V1OperatorType

class V1Rule(BaseModel):
    """
    V1Rule
    """
    applied_type: Optional[V1AppliedOnType] = Field(None, alias="appliedType")
    column_operator: Optional[V1OperatorType] = Field(None, alias="columnOperator")
    operator_value: Optional[StrictStr] = Field(None, alias="operatorValue")
    applied_field_name: Optional[StrictStr] = Field(None, alias="appliedFieldName")
    comparison_type: Optional[V1ComparisonType] = Field(None, alias="comparisonType")
    comparison_primitive_type: Optional[V1ComparisonDataType] = Field(None, alias="comparisonPrimitiveType")
    comparison_value: Optional[StrictStr] = Field(None, alias="comparisonValue")
    higher_index_range: Optional[StrictStr] = Field(None, alias="higherIndexRange")
    lower_index_range: Optional[StrictStr] = Field(None, alias="lowerIndexRange")
    is_higher_index_inclusive: Optional[StrictBool] = Field(None, alias="isHigherIndexInclusive")
    is_lower_index_inclusive: Optional[StrictBool] = Field(None, alias="isLowerIndexInclusive")
    sql: Optional[StrictStr] = None
    look_back_period: Optional[StrictInt] = Field(None, alias="lookBackPeriod")
    error_message: Optional[StrictStr] = Field(None, alias="errorMessage")
    contact_emails: Optional[conlist(StrictStr)] = Field(None, alias="contactEmails")
    bad_records_sql: Optional[StrictStr] = Field(None, alias="badRecordsSql")
    datadomain: Optional[StrictStr] = None
    provider_name: Optional[StrictStr] = Field(None, alias="providerName")
    arrival_extension: Optional[StrictStr] = Field(None, alias="arrivalExtension")
    arrival_folder: Optional[StrictStr] = Field(None, alias="arrivalFolder")
    expected_frequency: Optional[StrictStr] = Field(None, alias="expectedFrequency")
    sla: Optional[StrictStr] = None
    ingested_extension: Optional[StrictStr] = Field(None, alias="ingestedExtension")
    table_name: Optional[StrictStr] = Field(None, alias="tableName")
    __properties = ["appliedType", "columnOperator", "operatorValue", "appliedFieldName", "comparisonType", "comparisonPrimitiveType", "comparisonValue", "higherIndexRange", "lowerIndexRange", "isHigherIndexInclusive", "isLowerIndexInclusive", "sql", "lookBackPeriod", "errorMessage", "contactEmails", "badRecordsSql", "datadomain", "providerName", "arrivalExtension", "arrivalFolder", "expectedFrequency", "sla", "ingestedExtension", "tableName"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> V1Rule:
        """Create an instance of V1Rule from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> V1Rule:
        """Create an instance of V1Rule from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return V1Rule.parse_obj(obj)

        _obj = V1Rule.parse_obj({
            "applied_type": obj.get("appliedType"),
            "column_operator": obj.get("columnOperator"),
            "operator_value": obj.get("operatorValue"),
            "applied_field_name": obj.get("appliedFieldName"),
            "comparison_type": obj.get("comparisonType"),
            "comparison_primitive_type": obj.get("comparisonPrimitiveType"),
            "comparison_value": obj.get("comparisonValue"),
            "higher_index_range": obj.get("higherIndexRange"),
            "lower_index_range": obj.get("lowerIndexRange"),
            "is_higher_index_inclusive": obj.get("isHigherIndexInclusive"),
            "is_lower_index_inclusive": obj.get("isLowerIndexInclusive"),
            "sql": obj.get("sql"),
            "look_back_period": obj.get("lookBackPeriod"),
            "error_message": obj.get("errorMessage"),
            "contact_emails": obj.get("contactEmails"),
            "bad_records_sql": obj.get("badRecordsSql"),
            "datadomain": obj.get("datadomain"),
            "provider_name": obj.get("providerName"),
            "arrival_extension": obj.get("arrivalExtension"),
            "arrival_folder": obj.get("arrivalFolder"),
            "expected_frequency": obj.get("expectedFrequency"),
            "sla": obj.get("sla"),
            "ingested_extension": obj.get("ingestedExtension"),
            "table_name": obj.get("tableName")
        })
        return _obj

