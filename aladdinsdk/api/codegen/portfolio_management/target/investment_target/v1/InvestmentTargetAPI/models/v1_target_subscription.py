# coding: utf-8

"""
    Aladdin Investment Target

    This service provides advance capabilities to create and manage all types of Aladdin Investment Targets and their associated subscriptions.  # noqa: E501

    The version of the OpenAPI document: 1.3.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date, datetime
from typing import Optional, Union
from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from aladdinsdk.api.codegen.portfolio_management.target.investment_target.v1.InvestmentTargetAPI.models.v1_subscription_level import V1SubscriptionLevel
from aladdinsdk.api.codegen.portfolio_management.target.investment_target.v1.InvestmentTargetAPI.models.v1_subscription_state import V1SubscriptionState
from aladdinsdk.api.codegen.portfolio_management.target.investment_target.v1.InvestmentTargetAPI.models.v1_subscription_type import V1SubscriptionType

class V1TargetSubscription(BaseModel):
    """
    V1TargetSubscription
    """
    id: Optional[StrictStr] = None
    target_name: StrictStr = Field(..., alias="targetName")
    portfolio_ticker: Optional[StrictStr] = Field(None, alias="portfolioTicker")
    subscription_status: Optional[V1SubscriptionState] = Field(None, alias="subscriptionStatus")
    allocation_ratio: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="allocationRatio", description="Scalar ( i.e. traditional risk budget) used at the portfolio level to subscribe to the target.")
    target_nav: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="targetNav")
    start_date: date = Field(..., alias="startDate")
    end_date: Optional[date] = Field(None, alias="endDate")
    modifier: Optional[StrictStr] = None
    modify_time: Optional[datetime] = Field(None, alias="modifyTime")
    subscription_strategy: Optional[StrictStr] = Field(None, alias="subscriptionStrategy")
    subscription_type: Optional[V1SubscriptionType] = Field(None, alias="subscriptionType")
    subscribed_portfolio_group_ticker: Optional[StrictStr] = Field(None, alias="subscribedPortfolioGroupTicker")
    inherited_subscription: Optional[StrictBool] = Field(None, alias="inheritedSubscription")
    overridden_subscription: Optional[StrictBool] = Field(None, alias="overriddenSubscription")
    is_portfolio_group: Optional[StrictBool] = Field(None, alias="isPortfolioGroup")
    base_allocation_ratio: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="baseAllocationRatio", description="Scalar ( i.e. traditional risk budget) used at the portfolio group to subscribe to the target.")
    subscription_level: Optional[V1SubscriptionLevel] = Field(None, alias="subscriptionLevel")
    cash_buffer: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="cashBuffer")
    revision: Optional[StrictStr] = None
    __properties = ["id", "targetName", "portfolioTicker", "subscriptionStatus", "allocationRatio", "targetNav", "startDate", "endDate", "modifier", "modifyTime", "subscriptionStrategy", "subscriptionType", "subscribedPortfolioGroupTicker", "inheritedSubscription", "overriddenSubscription", "isPortfolioGroup", "baseAllocationRatio", "subscriptionLevel", "cashBuffer", "revision"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> V1TargetSubscription:
        """Create an instance of V1TargetSubscription from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> V1TargetSubscription:
        """Create an instance of V1TargetSubscription from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return V1TargetSubscription.parse_obj(obj)

        _obj = V1TargetSubscription.parse_obj({
            "id": obj.get("id"),
            "target_name": obj.get("targetName"),
            "portfolio_ticker": obj.get("portfolioTicker"),
            "subscription_status": obj.get("subscriptionStatus"),
            "allocation_ratio": obj.get("allocationRatio"),
            "target_nav": obj.get("targetNav"),
            "start_date": obj.get("startDate"),
            "end_date": obj.get("endDate"),
            "modifier": obj.get("modifier"),
            "modify_time": obj.get("modifyTime"),
            "subscription_strategy": obj.get("subscriptionStrategy"),
            "subscription_type": obj.get("subscriptionType"),
            "subscribed_portfolio_group_ticker": obj.get("subscribedPortfolioGroupTicker"),
            "inherited_subscription": obj.get("inheritedSubscription"),
            "overridden_subscription": obj.get("overriddenSubscription"),
            "is_portfolio_group": obj.get("isPortfolioGroup"),
            "base_allocation_ratio": obj.get("baseAllocationRatio"),
            "subscription_level": obj.get("subscriptionLevel"),
            "cash_buffer": obj.get("cashBuffer"),
            "revision": obj.get("revision")
        })
        return _obj

