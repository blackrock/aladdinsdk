# coding: utf-8

"""
    Portfolio Optimization 2.0

    Optimize portfolio positions to maximize expected returns and minimize risk and transaction costs.  # noqa: E501

    The version of the OpenAPI document: 2.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Dict, List, Optional, Union
from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, conlist
from aladdinsdk.api.codegen.analytics.portfolio_analytics.optimization.v2.OptimizationAPI.models.asset_universe_holdings_unit import AssetUniverseHoldingsUnit
from aladdinsdk.api.codegen.analytics.portfolio_analytics.optimization.v2.OptimizationAPI.models.types_analytics_portfolio_holding import TypesAnalyticsPortfolioHolding
from aladdinsdk.api.codegen.analytics.portfolio_analytics.optimization.v2.OptimizationAPI.models.types_analytics_position_type import TypesAnalyticsPositionType
from aladdinsdk.api.codegen.analytics.portfolio_analytics.optimization.v2.OptimizationAPI.models.v2_composite_universe import V2CompositeUniverse

class V2AssetUniverse(BaseModel):
    """
    V2AssetUniverse
    """
    initial_holdings: Optional[conlist(TypesAnalyticsPortfolioHolding)] = Field(None, alias="initialHoldings")
    benchmark_holdings: Optional[conlist(TypesAnalyticsPortfolioHolding)] = Field(None, alias="benchmarkHoldings")
    secondary_benchmark_ticker: Optional[StrictStr] = Field(None, alias="secondaryBenchmarkTicker")
    market_portfolio_ticker: Optional[StrictStr] = Field(None, alias="marketPortfolioTicker")
    additional_assets_ids: Optional[conlist(StrictStr)] = Field(None, alias="additionalAssetsIds")
    trade_universe_assets_ids: Optional[conlist(StrictStr)] = Field(None, alias="tradeUniverseAssetsIds")
    default_cash_asset_id: Optional[StrictStr] = Field(None, alias="defaultCashAssetId")
    cash_assets_ids: Optional[conlist(StrictStr)] = Field(None, alias="cashAssetsIds")
    override_market_value: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="overrideMarketValue")
    asset_prices: Optional[Dict[str, Union[StrictFloat, StrictInt]]] = Field(None, alias="assetPrices")
    asset_notional_prices: Optional[Dict[str, Union[StrictFloat, StrictInt]]] = Field(None, alias="assetNotionalPrices")
    currency_code: Optional[StrictStr] = Field(None, alias="currencyCode")
    holdings_unit: Optional[AssetUniverseHoldingsUnit] = Field(None, alias="holdingsUnit")
    position_type: Optional[TypesAnalyticsPositionType] = Field(None, alias="positionType")
    initial_cash_inject: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="initialCashInject")
    fx_hedged_assets: Optional[conlist(StrictStr)] = Field(None, alias="fxHedgedAssets")
    trades: Optional[conlist(TypesAnalyticsPortfolioHolding)] = None
    secondary_benchmark_holdings: Optional[conlist(TypesAnalyticsPortfolioHolding)] = Field(None, alias="secondaryBenchmarkHoldings")
    market_portfolio_holdings: Optional[conlist(TypesAnalyticsPortfolioHolding)] = Field(None, alias="marketPortfolioHoldings")
    use_default_benchmark: Optional[StrictBool] = Field(None, alias="useDefaultBenchmark")
    optimal_holdings: Optional[conlist(TypesAnalyticsPortfolioHolding)] = Field(None, alias="optimalHoldings")
    composite_universe: Optional[V2CompositeUniverse] = Field(None, alias="compositeUniverse")
    __properties = ["initialHoldings", "benchmarkHoldings", "secondaryBenchmarkTicker", "marketPortfolioTicker", "additionalAssetsIds", "tradeUniverseAssetsIds", "defaultCashAssetId", "cashAssetsIds", "overrideMarketValue", "assetPrices", "assetNotionalPrices", "currencyCode", "holdingsUnit", "positionType", "initialCashInject", "fxHedgedAssets", "trades", "secondaryBenchmarkHoldings", "marketPortfolioHoldings", "useDefaultBenchmark", "optimalHoldings", "compositeUniverse"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> V2AssetUniverse:
        """Create an instance of V2AssetUniverse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in initial_holdings (list)
        _items = []
        if self.initial_holdings:
            for _item in self.initial_holdings:
                if _item:
                    _items.append(_item.to_dict())
            _dict['initialHoldings'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in benchmark_holdings (list)
        _items = []
        if self.benchmark_holdings:
            for _item in self.benchmark_holdings:
                if _item:
                    _items.append(_item.to_dict())
            _dict['benchmarkHoldings'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in trades (list)
        _items = []
        if self.trades:
            for _item in self.trades:
                if _item:
                    _items.append(_item.to_dict())
            _dict['trades'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in secondary_benchmark_holdings (list)
        _items = []
        if self.secondary_benchmark_holdings:
            for _item in self.secondary_benchmark_holdings:
                if _item:
                    _items.append(_item.to_dict())
            _dict['secondaryBenchmarkHoldings'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in market_portfolio_holdings (list)
        _items = []
        if self.market_portfolio_holdings:
            for _item in self.market_portfolio_holdings:
                if _item:
                    _items.append(_item.to_dict())
            _dict['marketPortfolioHoldings'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in optimal_holdings (list)
        _items = []
        if self.optimal_holdings:
            for _item in self.optimal_holdings:
                if _item:
                    _items.append(_item.to_dict())
            _dict['optimalHoldings'] = _items
        # override the default output from pydantic by calling `to_dict()` of composite_universe
        if self.composite_universe:
            _dict['compositeUniverse'] = self.composite_universe.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> V2AssetUniverse:
        """Create an instance of V2AssetUniverse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return V2AssetUniverse.parse_obj(obj)

        _obj = V2AssetUniverse.parse_obj({
            "initial_holdings": [TypesAnalyticsPortfolioHolding.from_dict(_item) for _item in obj.get("initialHoldings")] if obj.get("initialHoldings") is not None else None,
            "benchmark_holdings": [TypesAnalyticsPortfolioHolding.from_dict(_item) for _item in obj.get("benchmarkHoldings")] if obj.get("benchmarkHoldings") is not None else None,
            "secondary_benchmark_ticker": obj.get("secondaryBenchmarkTicker"),
            "market_portfolio_ticker": obj.get("marketPortfolioTicker"),
            "additional_assets_ids": obj.get("additionalAssetsIds"),
            "trade_universe_assets_ids": obj.get("tradeUniverseAssetsIds"),
            "default_cash_asset_id": obj.get("defaultCashAssetId"),
            "cash_assets_ids": obj.get("cashAssetsIds"),
            "override_market_value": obj.get("overrideMarketValue"),
            "asset_prices": obj.get("assetPrices"),
            "asset_notional_prices": obj.get("assetNotionalPrices"),
            "currency_code": obj.get("currencyCode"),
            "holdings_unit": obj.get("holdingsUnit"),
            "position_type": obj.get("positionType"),
            "initial_cash_inject": obj.get("initialCashInject"),
            "fx_hedged_assets": obj.get("fxHedgedAssets"),
            "trades": [TypesAnalyticsPortfolioHolding.from_dict(_item) for _item in obj.get("trades")] if obj.get("trades") is not None else None,
            "secondary_benchmark_holdings": [TypesAnalyticsPortfolioHolding.from_dict(_item) for _item in obj.get("secondaryBenchmarkHoldings")] if obj.get("secondaryBenchmarkHoldings") is not None else None,
            "market_portfolio_holdings": [TypesAnalyticsPortfolioHolding.from_dict(_item) for _item in obj.get("marketPortfolioHoldings")] if obj.get("marketPortfolioHoldings") is not None else None,
            "use_default_benchmark": obj.get("useDefaultBenchmark"),
            "optimal_holdings": [TypesAnalyticsPortfolioHolding.from_dict(_item) for _item in obj.get("optimalHoldings")] if obj.get("optimalHoldings") is not None else None,
            "composite_universe": V2CompositeUniverse.from_dict(obj.get("compositeUniverse")) if obj.get("compositeUniverse") is not None else None
        })
        return _obj

