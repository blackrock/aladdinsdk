# coding: utf-8

"""
    Compliance Levels

    Retrieves start-of-day and intraday Compliance levels across portfolio and portfolio groups.  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date, datetime
from typing import Optional, Union
from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from aladdinsdk.api.codegen.compliance.state.level.v1.level.models.enums_compliance_rule_state import EnumsComplianceRuleState
from aladdinsdk.api.codegen.compliance.state.level.v1.level.models.enums_limit_type import EnumsLimitType

class V1Level(BaseModel):
    """
    Level resource...
    """
    portfolio_name: Optional[StrictStr] = Field(None, alias="portfolioName", description="Full name of a portfolio or portfolio group.")
    limit_definition: Optional[StrictStr] = Field(None, alias="limitDefinition")
    group_by: Optional[StrictStr] = Field(None, alias="groupBy", description="The specific data dimension e.g., issuer, sector, or currency used to aggregate holdings together for testing against the compliance limit, e.g., for a group by currency rule this would return CURRENCY.")
    level_definition: Optional[StrictStr] = Field(None, alias="levelDefinition", description="An expression representing the measure associated with the rule; this can be a simple measure, e.g., notional market value, or a more complicated mathematical expression, e.g., market value divided by net asset value.")
    level_definition_description: Optional[StrictStr] = Field(None, alias="levelDefinitionDescription", description="The description of the expression used to measure the portfolio or a group of holdings against the compliance limit.e.g. market value / NAV.")
    rule_name: Optional[StrictStr] = Field(None, alias="ruleName", description="A unique name for a rule in Aladdin Compliance. To get all the features associated with a rule please refer to the Rule API.")
    rule_id: Optional[StrictStr] = Field(None, alias="ruleId", description="Unique numeric identifier associated with the rule.")
    group: Optional[StrictStr] = Field(None, description="This field represents the identifier for the group being evaluated specifically for compliance rules which aggregate holdings along a specific data dimension e.g., for a group by currency rule this may return USD.")
    compliance_rule_state: Optional[EnumsComplianceRuleState] = Field(None, alias="complianceRuleState")
    portfolio_ticker: Optional[StrictStr] = Field(None, alias="portfolioTicker", description="A shorthand name which this portfolio was assigned in Aladdin.")
    rule_assignment_id: Optional[StrictStr] = Field(None, alias="ruleAssignmentId", description="Unique primary key identifier of an Aladdin rule assignment.")
    level: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="The rule's current numerical level, measured in terms of the rule's intended check, e.g., duration, percent of net asset value, market value, etc.")
    rule_assignment_name: Optional[StrictStr] = Field(None, alias="ruleAssignmentName", description="Name of the rule assignment.")
    limit_type: Optional[EnumsLimitType] = Field(None, alias="limitType")
    modify_time: Optional[datetime] = Field(None, alias="modifyTime", description="This records the latest timestamp when the item is entered or updated.")
    portfolio_id: Optional[StrictStr] = Field(None, alias="portfolioId", description="Aladdin unique numeric portfolio id, e.g. -1123.")
    room_to_limit: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="roomToLimit")
    room_to_limit_value: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="roomToLimitValue")
    condition_state: Optional[StrictBool] = Field(None, alias="conditionState", description="Indicates the rule's state. If the rule is in violation condition state will be false otherwise it will return true.")
    triggering_event: Optional[StrictStr] = Field(None, alias="triggeringEvent", description="The event that triggered the compliance evaluation.  This can include a transaction, a new cash activity or the end of day position calculation.")
    level_date: Optional[date] = Field(None, alias="levelDate", description="As of date for this data set.")
    limit_value: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="limitValue", description="The numerical minimum or maximum limit of the token.")
    as_traded_level: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="asTradedLevel", description="The rule's current as-traded numerical level, measured in terms of the rule's intended check, e.g., duration, percent of net asset value, market value, etc.")
    as_traded_condition_state: Optional[StrictBool] = Field(None, alias="asTradedConditionState", description="Indicates the rule's as-traded state. If the rule's as-traded level is in violation as-traded condition state will be false otherwise it will return true.")
    __properties = ["portfolioName", "limitDefinition", "groupBy", "levelDefinition", "levelDefinitionDescription", "ruleName", "ruleId", "group", "complianceRuleState", "portfolioTicker", "ruleAssignmentId", "level", "ruleAssignmentName", "limitType", "modifyTime", "portfolioId", "roomToLimit", "roomToLimitValue", "conditionState", "triggeringEvent", "levelDate", "limitValue", "asTradedLevel", "asTradedConditionState"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> V1Level:
        """Create an instance of V1Level from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> V1Level:
        """Create an instance of V1Level from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return V1Level.parse_obj(obj)

        _obj = V1Level.parse_obj({
            "portfolio_name": obj.get("portfolioName"),
            "limit_definition": obj.get("limitDefinition"),
            "group_by": obj.get("groupBy"),
            "level_definition": obj.get("levelDefinition"),
            "level_definition_description": obj.get("levelDefinitionDescription"),
            "rule_name": obj.get("ruleName"),
            "rule_id": obj.get("ruleId"),
            "group": obj.get("group"),
            "compliance_rule_state": obj.get("complianceRuleState"),
            "portfolio_ticker": obj.get("portfolioTicker"),
            "rule_assignment_id": obj.get("ruleAssignmentId"),
            "level": obj.get("level"),
            "rule_assignment_name": obj.get("ruleAssignmentName"),
            "limit_type": obj.get("limitType"),
            "modify_time": obj.get("modifyTime"),
            "portfolio_id": obj.get("portfolioId"),
            "room_to_limit": obj.get("roomToLimit"),
            "room_to_limit_value": obj.get("roomToLimitValue"),
            "condition_state": obj.get("conditionState"),
            "triggering_event": obj.get("triggeringEvent"),
            "level_date": obj.get("levelDate"),
            "limit_value": obj.get("limitValue"),
            "as_traded_level": obj.get("asTradedLevel"),
            "as_traded_condition_state": obj.get("asTradedConditionState")
        })
        return _obj

