# coding: utf-8

"""
    Compliance Rule Assignment

    Rule assignment assigns compliance rules for portfolio.  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date
from typing import Dict, List, Optional
from pydantic import BaseModel, Field, StrictBool, StrictStr, conlist
from aladdinsdk.api.codegen.compliance.state.compliance_rule_assignment.v1.compliance_rule_assignment.models.enums_compliance_rule_applicability_type import EnumsComplianceRuleApplicabilityType
from aladdinsdk.api.codegen.compliance.state.compliance_rule_assignment.v1.compliance_rule_assignment.models.enums_compliance_rule_assignment_review_state import EnumsComplianceRuleAssignmentReviewState
from aladdinsdk.api.codegen.compliance.state.compliance_rule_assignment.v1.compliance_rule_assignment.models.v1_customizable_rule_config import V1CustomizableRuleConfig
from aladdinsdk.api.codegen.compliance.state.compliance_rule_assignment.v1.compliance_rule_assignment.models.v1_simple_rule_config import V1SimpleRuleConfig

class V1ComplianceRuleAssignment(BaseModel):
    """
    V1ComplianceRuleAssignment
    """
    id: Optional[StrictStr] = None
    prohibition_rule_configurations: Optional[Dict[str, V1SimpleRuleConfig]] = Field(None, alias="prohibitionRuleConfigurations", description="Rule names and associated customizable components of each Prohibition Rule.")
    concentration_rule_configurations: Optional[Dict[str, V1CustomizableRuleConfig]] = Field(None, alias="concentrationRuleConfigurations", description="Rule names and associated customizable components of each Concentration Rule.")
    value_at_risk_rule_configurations: Optional[Dict[str, V1SimpleRuleConfig]] = Field(None, alias="valueAtRiskRuleConfigurations")
    scripted_rule_configurations: Optional[Dict[str, V1SimpleRuleConfig]] = Field(None, alias="scriptedRuleConfigurations", description="Rule names and associated customizable components of each Scripted Rule.")
    trade_rule_configurations: Optional[Dict[str, V1SimpleRuleConfig]] = Field(None, alias="tradeRuleConfigurations", description="Rule names and associated customizable components of each Trade Rule.")
    counterparty_rule_configurations: Optional[Dict[str, V1SimpleRuleConfig]] = Field(None, alias="counterpartyRuleConfigurations", description="Rule names and associated customizable components of each Counterparty Rule.")
    portfolio_names: Optional[conlist(StrictStr)] = Field(None, alias="portfolioNames", description="Portfolio name(s) to which rule is assigned.")
    approval_category: Optional[StrictStr] = Field(None, alias="approvalCategory")
    rule_assignment_source: Optional[StrictStr] = Field(None, alias="ruleAssignmentSource")
    category: Optional[StrictStr] = None
    effective_date: Optional[date] = Field(None, alias="effectiveDate")
    effective: Optional[StrictBool] = Field(None, description="The rule assignment's effective flag , defines if the rule assignment is effective. By default it is false.")
    review_state: Optional[EnumsComplianceRuleAssignmentReviewState] = Field(None, alias="reviewState")
    implementation_note: Optional[StrictStr] = Field(None, alias="implementationNote")
    excerpt: Optional[StrictStr] = Field(None, description="This is a documentation field used for the rule assignment excerpt.")
    reference: Optional[StrictStr] = Field(None, description="This is a documentation field used for the rule assignment reference links.")
    labels: Optional[conlist(StrictStr)] = None
    regulator: Optional[StrictStr] = Field(None, description="(-- api-linter: core::0203::required=disabled  aip.dev/not-precedent: We need to do this because it is only required when a different field is set and the given description is for informational use --) Regulating body of the the rule assignment. It is a required field when rule assignment source is 'REGULATORY'.")
    deadline: Optional[StrictStr] = None
    jurisdiction_country_code: Optional[StrictStr] = Field(None, alias="jurisdictionCountryCode", description="(-- api-linter: core::0203::required=disabled  aip.dev/not-precedent: We need to do this because it is only required when a different field is set and the given description is for informational use --) Jurisdiction country code. It is a required field when rule assignment source is 'REGULATORY'.")
    documentation_link: Optional[StrictStr] = Field(None, alias="documentationLink", description="This is a documentation field used for the rule assignment documentation links.")
    override_action: Optional[StrictStr] = Field(None, alias="overrideAction", description="This is a documentation field used for the rule assignment override action.")
    resolution_action: Optional[StrictStr] = Field(None, alias="resolutionAction", description="This is a documentation field used for the rule assignment resolution action.")
    termination_date: Optional[date] = Field(None, alias="terminationDate", description="Date and time when this rule assignment would be terminated.")
    constraint_applicability_type: Optional[EnumsComplianceRuleApplicabilityType] = Field(None, alias="constraintApplicabilityType")
    assignment_name: Optional[StrictStr] = Field(None, alias="assignmentName")
    resolution_requires_four_eyes_approval: Optional[StrictBool] = Field(None, alias="resolutionRequiresFourEyesApproval", description="The rule assignment's violation4EyesFlag flag. By default it is false.")
    __properties = ["id", "prohibitionRuleConfigurations", "concentrationRuleConfigurations", "valueAtRiskRuleConfigurations", "scriptedRuleConfigurations", "tradeRuleConfigurations", "counterpartyRuleConfigurations", "portfolioNames", "approvalCategory", "ruleAssignmentSource", "category", "effectiveDate", "effective", "reviewState", "implementationNote", "excerpt", "reference", "labels", "regulator", "deadline", "jurisdictionCountryCode", "documentationLink", "overrideAction", "resolutionAction", "terminationDate", "constraintApplicabilityType", "assignmentName", "resolutionRequiresFourEyesApproval"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> V1ComplianceRuleAssignment:
        """Create an instance of V1ComplianceRuleAssignment from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each value in prohibition_rule_configurations (dict)
        _field_dict = {}
        if self.prohibition_rule_configurations:
            for _key in self.prohibition_rule_configurations:
                if self.prohibition_rule_configurations[_key]:
                    _field_dict[_key] = self.prohibition_rule_configurations[_key].to_dict()
            _dict['prohibitionRuleConfigurations'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in concentration_rule_configurations (dict)
        _field_dict = {}
        if self.concentration_rule_configurations:
            for _key in self.concentration_rule_configurations:
                if self.concentration_rule_configurations[_key]:
                    _field_dict[_key] = self.concentration_rule_configurations[_key].to_dict()
            _dict['concentrationRuleConfigurations'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in value_at_risk_rule_configurations (dict)
        _field_dict = {}
        if self.value_at_risk_rule_configurations:
            for _key in self.value_at_risk_rule_configurations:
                if self.value_at_risk_rule_configurations[_key]:
                    _field_dict[_key] = self.value_at_risk_rule_configurations[_key].to_dict()
            _dict['valueAtRiskRuleConfigurations'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in scripted_rule_configurations (dict)
        _field_dict = {}
        if self.scripted_rule_configurations:
            for _key in self.scripted_rule_configurations:
                if self.scripted_rule_configurations[_key]:
                    _field_dict[_key] = self.scripted_rule_configurations[_key].to_dict()
            _dict['scriptedRuleConfigurations'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in trade_rule_configurations (dict)
        _field_dict = {}
        if self.trade_rule_configurations:
            for _key in self.trade_rule_configurations:
                if self.trade_rule_configurations[_key]:
                    _field_dict[_key] = self.trade_rule_configurations[_key].to_dict()
            _dict['tradeRuleConfigurations'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in counterparty_rule_configurations (dict)
        _field_dict = {}
        if self.counterparty_rule_configurations:
            for _key in self.counterparty_rule_configurations:
                if self.counterparty_rule_configurations[_key]:
                    _field_dict[_key] = self.counterparty_rule_configurations[_key].to_dict()
            _dict['counterpartyRuleConfigurations'] = _field_dict
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> V1ComplianceRuleAssignment:
        """Create an instance of V1ComplianceRuleAssignment from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return V1ComplianceRuleAssignment.parse_obj(obj)

        _obj = V1ComplianceRuleAssignment.parse_obj({
            "id": obj.get("id"),
            "prohibition_rule_configurations": dict(
                (_k, V1SimpleRuleConfig.from_dict(_v))
                for _k, _v in obj.get("prohibitionRuleConfigurations").items()
            )
            if obj.get("prohibitionRuleConfigurations") is not None
            else None,
            "concentration_rule_configurations": dict(
                (_k, V1CustomizableRuleConfig.from_dict(_v))
                for _k, _v in obj.get("concentrationRuleConfigurations").items()
            )
            if obj.get("concentrationRuleConfigurations") is not None
            else None,
            "value_at_risk_rule_configurations": dict(
                (_k, V1SimpleRuleConfig.from_dict(_v))
                for _k, _v in obj.get("valueAtRiskRuleConfigurations").items()
            )
            if obj.get("valueAtRiskRuleConfigurations") is not None
            else None,
            "scripted_rule_configurations": dict(
                (_k, V1SimpleRuleConfig.from_dict(_v))
                for _k, _v in obj.get("scriptedRuleConfigurations").items()
            )
            if obj.get("scriptedRuleConfigurations") is not None
            else None,
            "trade_rule_configurations": dict(
                (_k, V1SimpleRuleConfig.from_dict(_v))
                for _k, _v in obj.get("tradeRuleConfigurations").items()
            )
            if obj.get("tradeRuleConfigurations") is not None
            else None,
            "counterparty_rule_configurations": dict(
                (_k, V1SimpleRuleConfig.from_dict(_v))
                for _k, _v in obj.get("counterpartyRuleConfigurations").items()
            )
            if obj.get("counterpartyRuleConfigurations") is not None
            else None,
            "portfolio_names": obj.get("portfolioNames"),
            "approval_category": obj.get("approvalCategory"),
            "rule_assignment_source": obj.get("ruleAssignmentSource"),
            "category": obj.get("category"),
            "effective_date": obj.get("effectiveDate"),
            "effective": obj.get("effective"),
            "review_state": obj.get("reviewState"),
            "implementation_note": obj.get("implementationNote"),
            "excerpt": obj.get("excerpt"),
            "reference": obj.get("reference"),
            "labels": obj.get("labels"),
            "regulator": obj.get("regulator"),
            "deadline": obj.get("deadline"),
            "jurisdiction_country_code": obj.get("jurisdictionCountryCode"),
            "documentation_link": obj.get("documentationLink"),
            "override_action": obj.get("overrideAction"),
            "resolution_action": obj.get("resolutionAction"),
            "termination_date": obj.get("terminationDate"),
            "constraint_applicability_type": obj.get("constraintApplicabilityType"),
            "assignment_name": obj.get("assignmentName"),
            "resolution_requires_four_eyes_approval": obj.get("resolutionRequiresFourEyesApproval")
        })
        return _obj

