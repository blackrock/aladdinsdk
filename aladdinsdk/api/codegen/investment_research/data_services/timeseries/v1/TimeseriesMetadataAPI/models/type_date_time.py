# coding: utf-8

"""
    Timeseries Metadata

    Timeseries Metadata offers the capability to create, update, delete and search for metadata information about each timeseries data.  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Optional
from pydantic import BaseModel, Field, StrictInt, StrictStr
from aladdinsdk.api.codegen.investment_research.data_services.timeseries.v1.TimeseriesMetadataAPI.models.type_time_zone import TypeTimeZone

class TypeDateTime(BaseModel):
    """
    * When utc_offset is set and time_zone is unset: a civil time on a calendar    day with a particular offset from UTC.  * When time_zone is set and utc_offset is unset: a civil time on a calendar    day in a particular time zone.  * When neither time_zone nor utc_offset is set: a civil time on a calendar    day in local time.  The date is relative to the Proleptic Gregorian Calendar.  If year is 0, the DateTime is considered not to have a specific year. month and day must have valid, non-zero values.  This type is more flexible than some applications may want. Make sure to document and validate your application's limitations.
    """
    year: Optional[StrictInt] = Field(None, description="Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a datetime without a year.")
    month: Optional[StrictInt] = Field(None, description="Required. Month of year. Must be from 1 to 12.")
    day: Optional[StrictInt] = Field(None, description="Required. Day of month. Must be from 1 to 31 and valid for the year and month.")
    hours: Optional[StrictInt] = Field(None, description="Required. Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value \"24:00:00\" for scenarios like business closing time.")
    minutes: Optional[StrictInt] = Field(None, description="Required. Minutes of hour of day. Must be from 0 to 59.")
    seconds: Optional[StrictInt] = Field(None, description="Required. Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.")
    nanos: Optional[StrictInt] = Field(None, description="Required. Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.")
    utc_offset: Optional[StrictStr] = Field(None, alias="utcOffset", description="UTC offset. Must be whole seconds, between -18 hours and +18 hours. For example, a UTC offset of -4:00 would be represented as { seconds: -14400 }.")
    time_zone: Optional[TypeTimeZone] = Field(None, alias="timeZone")
    __properties = ["year", "month", "day", "hours", "minutes", "seconds", "nanos", "utcOffset", "timeZone"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> TypeDateTime:
        """Create an instance of TypeDateTime from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of time_zone
        if self.time_zone:
            _dict['timeZone'] = self.time_zone.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> TypeDateTime:
        """Create an instance of TypeDateTime from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return TypeDateTime.parse_obj(obj)

        _obj = TypeDateTime.parse_obj({
            "year": obj.get("year"),
            "month": obj.get("month"),
            "day": obj.get("day"),
            "hours": obj.get("hours"),
            "minutes": obj.get("minutes"),
            "seconds": obj.get("seconds"),
            "nanos": obj.get("nanos"),
            "utc_offset": obj.get("utcOffset"),
            "time_zone": TypeTimeZone.from_dict(obj.get("timeZone")) if obj.get("timeZone") is not None else None
        })
        return _obj

