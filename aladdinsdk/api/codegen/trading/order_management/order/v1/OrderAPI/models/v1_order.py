# coding: utf-8

"""
    Order

    Filter, post or cancel orders. An order is a directive from a portfolio manager to the trading desk to execute a particular investment decision.  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date, datetime
from typing import List, Optional, Union
from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, conlist
from aladdinsdk.api.codegen.trading.order_management.order.v1.OrderAPI.models.enums_assigned_to_status import EnumsAssignedToStatus
from aladdinsdk.api.codegen.trading.order_management.order.v1.OrderAPI.models.enums_financing_type import EnumsFinancingType
from aladdinsdk.api.codegen.trading.order_management.order.v1.OrderAPI.models.enums_owner_type import EnumsOwnerType
from aladdinsdk.api.codegen.trading.order_management.order.v1.OrderAPI.models.v1_external_order_reference import V1ExternalOrderReference
from aladdinsdk.api.codegen.trading.order_management.order.v1.OrderAPI.models.v1_order_asset_reference import V1OrderAssetReference
from aladdinsdk.api.codegen.trading.order_management.order.v1.OrderAPI.models.v1_order_comment import V1OrderComment
from aladdinsdk.api.codegen.trading.order_management.order.v1.OrderAPI.models.v1_order_detail import V1OrderDetail
from aladdinsdk.api.codegen.trading.order_management.order.v1.OrderAPI.models.v1_order_flag import V1OrderFlag

class V1Order(BaseModel):
    """
    An order is a directive from a portfolio manager to the trading desk to execute a particular investment decision.
    """
    id: Optional[StrictStr] = None
    order_status: Optional[StrictStr] = Field(None, alias="orderStatus", description="Aladdin order status. Examples: \"Open\", \"Compl Pending\", \"Authorized\", \"Active\", \"Expired\", \"Rejected\", \"Canceled\", \"Booked\". Contact Aladdin Support for full list of accepted values.")
    order_details: Optional[conlist(V1OrderDetail)] = Field(None, alias="orderDetails")
    external_order_reference: Optional[V1ExternalOrderReference] = Field(None, alias="externalOrderReference")
    order_source: Optional[StrictStr] = Field(None, alias="orderSource", description="Source of the modification to the order, this can be a user ID or a system like TRADES.")
    asset_id: Optional[StrictStr] = Field(None, alias="assetId")
    asset_reference: Optional[V1OrderAssetReference] = Field(None, alias="assetReference")
    transaction_type: Optional[StrictStr] = Field(None, alias="transactionType", description="Transaction type of the order. Examples: \"BUY\", \"SELL\". Contact Aladdin Support for full list of accepted values.")
    settle_date: Optional[date] = Field(None, alias="settleDate")
    order_date: Optional[date] = Field(None, alias="orderDate")
    trade_date: Optional[date] = Field(None, alias="tradeDate")
    basket_id: Optional[StrictStr] = Field(None, alias="basketId", description="Users may provide a Basket ID to mark orders that are related to each other. For example, if ten orders are raised for ten securities which are part of a basket trade or program trade or any other type of multi-order trade, the same free-form Basket ID text can be specified across all of these orders for the purpose of tagging. The Basket ID is entered into Aladdin as is and is visible in the \"Basket\" column in Order Monitor of Aladdin Dashboard. A limit of 64 characters is applied. Values over the limit will be truncated.")
    market_price: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="marketPrice")
    settle_currency_code: Optional[StrictStr] = Field(None, alias="settleCurrencyCode")
    trading_limit_type: Optional[StrictStr] = Field(None, alias="tradingLimitType", description="Limit type of the order. Examples: \"Price\", \"Yield\". Contact Aladdin Support for full list of accepted values.")
    trading_limit_value: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="tradingLimitValue")
    trading_stop_type: Optional[StrictStr] = Field(None, alias="tradingStopType", description="Limit stop type of the order. Examples: \"Price\", \"Yield\". Contact Aladdin Support for full list of accepted values.")
    trading_stop_value: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="tradingStopValue")
    order_type: Optional[StrictStr] = Field(None, alias="orderType")
    expiration_type: Optional[StrictStr] = Field(None, alias="expirationType", description="Expiration type. Examples: \"Day\", \"Good Till Cancel\". Contact Aladdin Support for full list of accepted values.")
    expiration_date: Optional[date] = Field(None, alias="expirationDate")
    pm_instruction: Optional[StrictStr] = Field(None, alias="pmInstruction", description="Update instructions for the order. Examples: \"100% Complete\", \"Approved\". Contact Aladdin Support for full list of accepted values.")
    pm_initials: Optional[StrictStr] = Field(None, alias="pmInitials")
    trader_initials: Optional[StrictStr] = Field(None, alias="traderInitials")
    trade_purpose: Optional[StrictStr] = Field(None, alias="tradePurpose", description="Trade purpose. Examples: \"Origination\", \"Arbitrage\". Contact Aladdin Support for full list of accepted values.")
    directed_counterparty: Optional[StrictStr] = Field(None, alias="directedCounterparty")
    assigned_to: Optional[StrictStr] = Field(None, alias="assignedTo")
    assigned_to_status: Optional[EnumsAssignedToStatus] = Field(None, alias="assignedToStatus")
    directed_broker_account: Optional[StrictStr] = Field(None, alias="directedBrokerAccount")
    counterparty_id: Optional[StrictStr] = Field(None, alias="counterpartyId", description="Numerical ID associated with the counterparty. This can be retrieved using the Brokers API.")
    external_counterparty_id: Optional[StrictStr] = Field(None, alias="externalCounterpartyId", description="The client-provided non-Aladdin identifier of the executing broker. This is an input-only field that may be used in place of the counterpartyId to select the counterparty via an external account code.")
    duration: Optional[Union[StrictFloat, StrictInt]] = None
    convexity: Optional[Union[StrictFloat, StrictInt]] = None
    deal_id: Optional[StrictStr] = Field(None, alias="dealId", description="Deal ID is a freeform string that is used to link two orders together. See deal type for further information.  When used as a request input, assign the orders by specifying the same string value to connect all the related orders. This ID will be reassigned with a system-wide unique identifier after the orders are posted, and is returned in this field in the order response.")
    deal_type: Optional[StrictStr] = Field(None, alias="dealType", description="Deal type is the order relationship type. Valid values are: SWAP, SWITCH, PACKAGE, CSWAP, ROLL, SPREAD, RND_ROBIN, COVERED_OPT. Use this field in conjunction with deal ID to establish a relationship between two orders.")
    settle_date_offset: Optional[StrictInt] = Field(None, alias="settleDateOffset")
    trader_folder: Optional[StrictStr] = Field(None, alias="traderFolder", description="Grouping identifier for traders.")
    dealing_capacity: Optional[StrictStr] = Field(None, alias="dealingCapacity", description="Dealing capacity. Examples: \"Agency Basis\", \"Principal Basis\". Contact Aladdin Support for full list of accepted values.")
    unit_type: Optional[StrictStr] = Field(None, alias="unitType", description="The Unit type of the order Examples: \"VALUE\". Contact Aladdin Support for full list of accepted values.")
    execution_instruction: Optional[StrictStr] = Field(None, alias="executionInstruction", description="Execution instrutions. Examples: \"All or None\", \"Do not Increase\". Contact Aladdin Support for full list of accepted values.")
    trading_benchmark: Optional[StrictStr] = Field(None, alias="tradingBenchmark", description="Trading benchmark. Examples: \"Market\", \"Best Effort\". Contact Aladdin Support for full list of accepted values.")
    trading_benchmark_date: Optional[date] = Field(None, alias="tradingBenchmarkDate")
    trading_benchmark_price: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="tradingBenchmarkPrice")
    active_time: Optional[datetime] = Field(None, alias="activeTime", description="Time when the order was activated by trader.")
    authorize_time: Optional[datetime] = Field(None, alias="authorizeTime", description="Time when the order was authorized. Note regarding the PM/Trader split model: The PM authorizes the order which populates the AUTH_TIME on the PM order. From the authorized PM order, the trader order is created. The trader does not authorize the trader order; rather, the trader order inherits the AUTH_TIME from the PM order. One may see the situation of having the authorizeTime before the entryTime on the trader orders where the order is authorized before it was created.")
    entry_time: Optional[datetime] = Field(None, alias="entryTime")
    factor: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="Factor of the security for the given factor date. For floating rate securities that do not pay down, the factor will always be set to 1.")
    factor_date: Optional[date] = Field(None, alias="factorDate", description="The effective date of the factor.")
    interest: Optional[Union[StrictFloat, StrictInt]] = None
    modifier: Optional[StrictStr] = None
    modify_time: Optional[datetime] = Field(None, alias="modifyTime")
    principal: Optional[Union[StrictFloat, StrictInt]] = None
    soft_dollar_flag: Optional[StrictBool] = Field(None, alias="softDollarFlag")
    version: Optional[StrictInt] = Field(None, description="Version number. Each time the order is updated, the version may or may not increment based on business rules, but the touch count will increment.")
    market_yield: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="marketYield")
    owner_type: Optional[EnumsOwnerType] = Field(None, alias="ownerType")
    average_price: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="averagePrice")
    assign_to_rule: Optional[StrictStr] = Field(None, alias="assignToRule")
    raiser: Optional[StrictStr] = None
    touch_count: Optional[StrictInt] = Field(None, alias="touchCount", description="This number will be incremented every time the order is touched.")
    urgency: Optional[StrictStr] = Field(None, description="Urgency of the order. Examples: \"1\", \"2\". Contact Aladdin Support for full list of accepted values.")
    order_comments: Optional[conlist(V1OrderComment)] = Field(None, alias="orderComments", description="Comments on the order.")
    flags: Optional[conlist(V1OrderFlag)] = None
    reference_asset_id: Optional[StrictStr] = Field(None, alias="referenceAssetId")
    reference_haircut: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="referenceHaircut")
    reference_price: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="referencePrice")
    financing_type: Optional[EnumsFinancingType] = Field(None, alias="financingType")
    face: Optional[Union[StrictFloat, StrictInt]] = None
    internal_unique_key: Optional[StrictInt] = Field(None, alias="internalUniqueKey")
    relationships: Optional[conlist(StrictInt)] = None
    fill_amount: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="fillAmount")
    split_source: Optional[StrictInt] = Field(None, alias="splitSource")
    merged_destination: Optional[StrictInt] = Field(None, alias="mergedDestination")
    __properties = ["id", "orderStatus", "orderDetails", "externalOrderReference", "orderSource", "assetId", "assetReference", "transactionType", "settleDate", "orderDate", "tradeDate", "basketId", "marketPrice", "settleCurrencyCode", "tradingLimitType", "tradingLimitValue", "tradingStopType", "tradingStopValue", "orderType", "expirationType", "expirationDate", "pmInstruction", "pmInitials", "traderInitials", "tradePurpose", "directedCounterparty", "assignedTo", "assignedToStatus", "directedBrokerAccount", "counterpartyId", "externalCounterpartyId", "duration", "convexity", "dealId", "dealType", "settleDateOffset", "traderFolder", "dealingCapacity", "unitType", "executionInstruction", "tradingBenchmark", "tradingBenchmarkDate", "tradingBenchmarkPrice", "activeTime", "authorizeTime", "entryTime", "factor", "factorDate", "interest", "modifier", "modifyTime", "principal", "softDollarFlag", "version", "marketYield", "ownerType", "averagePrice", "assignToRule", "raiser", "touchCount", "urgency", "orderComments", "flags", "referenceAssetId", "referenceHaircut", "referencePrice", "financingType", "face", "internalUniqueKey", "relationships", "fillAmount", "splitSource", "mergedDestination"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> V1Order:
        """Create an instance of V1Order from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                            "order_status",
                            "order_source",
                            "active_time",
                            "authorize_time",
                            "entry_time",
                            "modify_time",
                            "version",
                            "internal_unique_key",
                            "relationships",
                            "fill_amount",
                            "split_source",
                            "merged_destination",
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in order_details (list)
        _items = []
        if self.order_details:
            for _item in self.order_details:
                if _item:
                    _items.append(_item.to_dict())
            _dict['orderDetails'] = _items
        # override the default output from pydantic by calling `to_dict()` of external_order_reference
        if self.external_order_reference:
            _dict['externalOrderReference'] = self.external_order_reference.to_dict()
        # override the default output from pydantic by calling `to_dict()` of asset_reference
        if self.asset_reference:
            _dict['assetReference'] = self.asset_reference.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in order_comments (list)
        _items = []
        if self.order_comments:
            for _item in self.order_comments:
                if _item:
                    _items.append(_item.to_dict())
            _dict['orderComments'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in flags (list)
        _items = []
        if self.flags:
            for _item in self.flags:
                if _item:
                    _items.append(_item.to_dict())
            _dict['flags'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> V1Order:
        """Create an instance of V1Order from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return V1Order.parse_obj(obj)

        _obj = V1Order.parse_obj({
            "id": obj.get("id"),
            "order_status": obj.get("orderStatus"),
            "order_details": [V1OrderDetail.from_dict(_item) for _item in obj.get("orderDetails")] if obj.get("orderDetails") is not None else None,
            "external_order_reference": V1ExternalOrderReference.from_dict(obj.get("externalOrderReference")) if obj.get("externalOrderReference") is not None else None,
            "order_source": obj.get("orderSource"),
            "asset_id": obj.get("assetId"),
            "asset_reference": V1OrderAssetReference.from_dict(obj.get("assetReference")) if obj.get("assetReference") is not None else None,
            "transaction_type": obj.get("transactionType"),
            "settle_date": obj.get("settleDate"),
            "order_date": obj.get("orderDate"),
            "trade_date": obj.get("tradeDate"),
            "basket_id": obj.get("basketId"),
            "market_price": obj.get("marketPrice"),
            "settle_currency_code": obj.get("settleCurrencyCode"),
            "trading_limit_type": obj.get("tradingLimitType"),
            "trading_limit_value": obj.get("tradingLimitValue"),
            "trading_stop_type": obj.get("tradingStopType"),
            "trading_stop_value": obj.get("tradingStopValue"),
            "order_type": obj.get("orderType"),
            "expiration_type": obj.get("expirationType"),
            "expiration_date": obj.get("expirationDate"),
            "pm_instruction": obj.get("pmInstruction"),
            "pm_initials": obj.get("pmInitials"),
            "trader_initials": obj.get("traderInitials"),
            "trade_purpose": obj.get("tradePurpose"),
            "directed_counterparty": obj.get("directedCounterparty"),
            "assigned_to": obj.get("assignedTo"),
            "assigned_to_status": obj.get("assignedToStatus"),
            "directed_broker_account": obj.get("directedBrokerAccount"),
            "counterparty_id": obj.get("counterpartyId"),
            "external_counterparty_id": obj.get("externalCounterpartyId"),
            "duration": obj.get("duration"),
            "convexity": obj.get("convexity"),
            "deal_id": obj.get("dealId"),
            "deal_type": obj.get("dealType"),
            "settle_date_offset": obj.get("settleDateOffset"),
            "trader_folder": obj.get("traderFolder"),
            "dealing_capacity": obj.get("dealingCapacity"),
            "unit_type": obj.get("unitType"),
            "execution_instruction": obj.get("executionInstruction"),
            "trading_benchmark": obj.get("tradingBenchmark"),
            "trading_benchmark_date": obj.get("tradingBenchmarkDate"),
            "trading_benchmark_price": obj.get("tradingBenchmarkPrice"),
            "active_time": obj.get("activeTime"),
            "authorize_time": obj.get("authorizeTime"),
            "entry_time": obj.get("entryTime"),
            "factor": obj.get("factor"),
            "factor_date": obj.get("factorDate"),
            "interest": obj.get("interest"),
            "modifier": obj.get("modifier"),
            "modify_time": obj.get("modifyTime"),
            "principal": obj.get("principal"),
            "soft_dollar_flag": obj.get("softDollarFlag"),
            "version": obj.get("version"),
            "market_yield": obj.get("marketYield"),
            "owner_type": obj.get("ownerType"),
            "average_price": obj.get("averagePrice"),
            "assign_to_rule": obj.get("assignToRule"),
            "raiser": obj.get("raiser"),
            "touch_count": obj.get("touchCount"),
            "urgency": obj.get("urgency"),
            "order_comments": [V1OrderComment.from_dict(_item) for _item in obj.get("orderComments")] if obj.get("orderComments") is not None else None,
            "flags": [V1OrderFlag.from_dict(_item) for _item in obj.get("flags")] if obj.get("flags") is not None else None,
            "reference_asset_id": obj.get("referenceAssetId"),
            "reference_haircut": obj.get("referenceHaircut"),
            "reference_price": obj.get("referencePrice"),
            "financing_type": obj.get("financingType"),
            "face": obj.get("face"),
            "internal_unique_key": obj.get("internalUniqueKey"),
            "relationships": obj.get("relationships"),
            "fill_amount": obj.get("fillAmount"),
            "split_source": obj.get("splitSource"),
            "merged_destination": obj.get("mergedDestination")
        })
        return _obj

